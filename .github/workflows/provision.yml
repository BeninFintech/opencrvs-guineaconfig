name: Provision environment
run-name: Provision ${{ github.event.inputs.environment }}
on:
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        description: Machine to provision
        default: qa
        required: true
        options:
          - development
          - staging
          - qa
          - production
          - backup
      tag:
        type: choice
        description: Select group tag you want to execute
        default: all
        options:
          - all
          - backups
          - checks
          - updates
          - application
          - tools
          - docker
          - deployment
          - users
          - crontab
          - mongodb
          - data-partition
          - swap
          - ufw
          - fail2ban
          - decrypt
          - swarm
          - elasticsearch
          - traefik
      debug:
        type: boolean
        description: Open SSH session to the runner after deployment
        default: false
jobs:
  check-backup-environment:
    name: Check if backup environment exists
    runs-on: ubuntu-22.04
    outputs:
      backup_env_exists: ${{ steps.check-env.outputs.exists }}
    steps:
      - name: Check if GITHUB_TOKEN is set
        id: check-token
        run: |
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "Environment secret GITHUB_TOKEN is not set. Make sure you add a correct Github API token before running this pipeline."
            exit 1
          fi

      - name: Check if backup environment exists
        id: check-env
        run: |
          ENV_NAME="backup"
          RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                            "https://api.github.com/repos/${{ github.repository }}/environments/$ENV_NAME")
          if echo "$RESPONSE" | grep -q '"name": "'$ENV_NAME'"'; then
            echo "Environment $ENV_NAME exists."
            echo "::set-output name=exists::true"
          else
            echo "Environment $ENV_NAME does not exist."
            echo "::set-output name=exists::false"
          fi

  fetch-backup-credentials:
    name: Fetch SSH credentials for backup environment
    needs: check-backup-environment
    runs-on: ubuntu-22.04
    environment: backup
    if: needs.check-backup-environment.outputs.backup_env_exists == 'true'
    outputs:
      backup-ssh-key: ${{ steps.fetch-credentials.outputs.backup-ssh-key }}
    steps:
      - name: Fetch backup SSH key
        id: fetch-credentials
        run: |
          SSH_KEY="${{ secrets.SSH_KEY }}"
          echo -n "$SSH_KEY" | openssl enc -aes-256-cbc -pbkdf2 -salt -k "${{ secrets.GH_ENCRYPTION_PASSWORD }}" -out encrypted_key.bin
          ENCODED_ENCRYPTED_SECRET=$(base64 < encrypted_key.bin)
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "backup-ssh-key<<$EOF" >> $GITHUB_OUTPUT
          echo "$ENCODED_ENCRYPTED_SECRET" >> $GITHUB_OUTPUT
          echo "$EOF" >> $GITHUB_OUTPUT

  check-production-environment:
    name: Check if production environment exists
    if: ${{ github.event.inputs.environment == 'staging' }}
    runs-on: ubuntu-22.04
    outputs:
      production_env_exists: ${{ steps.check-env.outputs.exists }}
    steps:
      - name: Check if GITHUB_TOKEN is set
        id: check-token
        run: |
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "Environment secret GITHUB_TOKEN is not set. Make sure you add a correct Github API token before running this pipeline."
            exit 1
          fi

      - name: Check if backup environment exists
        id: check-env
        run: |
          ENV_NAME="backup"
          RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                            "https://api.github.com/repos/${{ github.repository }}/environments/$ENV_NAME")
          if echo "$RESPONSE" | grep -q '"name": "'$ENV_NAME'"'; then
            echo "Environment $ENV_NAME exists."
            echo "::set-output name=exists::true"
          else
            echo "Environment $ENV_NAME does not exist."
            echo "::set-output name=exists::false"
          fi

  fetch-production-credentials:
    name: Fetch backup encryption key for production environment to be used in periodic restore
    needs: check-production-environment
    runs-on: ubuntu-22.04
    environment: production
    if: needs.check-production-environment.outputs.production_env_exists == 'true' && github.event.inputs.environment == 'staging'
    outputs:
      production-decryption-key: ${{ steps.fetch-credentials.outputs.production-decryption-key }}
    steps:
      - name: Fetch decryption key
        id: fetch-credentials
        run: |
          BACKUP_ENCRYPTION_PASSPHRASE="${{ secrets.BACKUP_ENCRYPTION_PASSPHRASE }}"
          echo -n "$BACKUP_ENCRYPTION_PASSPHRASE" | openssl enc -aes-256-cbc -pbkdf2 -salt -k "${{ secrets.GH_ENCRYPTION_PASSWORD }}" -out encrypted_key.bin
          ENCODED_ENCRYPTED_SECRET=$(base64 < encrypted_key.bin)
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "production-decryption-key<<$EOF" >> $GITHUB_OUTPUT
          echo "$ENCODED_ENCRYPTED_SECRET" >> $GITHUB_OUTPUT
          echo "$EOF" >> $GITHUB_OUTPUT

  provision:
    name: Provision ${{ github.event.inputs.environment }}
    environment: ${{ github.event.inputs.environment }}
    needs:
      [
        check-backup-environment,
        fetch-backup-credentials,
        fetch-production-credentials
      ]
    if: always()
    runs-on: ubuntu-22.04
    outputs:
      outcome: ${{ steps.deploy.outcome }}
    timeout-minutes: 60
    steps:
      - name: Clone country config resource package
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          path: './${{ github.event.repository.name }}'

      - name: Insert production encryption key to environment variables
        if: github.event.inputs.environment == 'staging'
        run: |
          echo "${{ needs.fetch-production-credentials.outputs.production-decryption-key }}" | base64 --decode | \
          openssl enc -aes-256-cbc -pbkdf2 -d -salt -k "${{ secrets.GH_ENCRYPTION_PASSWORD }}" -out /tmp/backup_encryption_key
          BACKUP_RESTORE_ENCRYPTION_PASSPHRASE=$(cat /tmp/backup_encryption_key)
          echo "backup_restore_encryption_passphrase=$BACKUP_RESTORE_ENCRYPTION_PASSPHRASE" >> $GITHUB_ENV
          echo "::add-mask::$BACKUP_RESTORE_ENCRYPTION_PASSPHRASE"

      - name: Set variables for ansible
        id: ansible-variables
        run: |
          JSON_WITH_NEWLINES=$(cat<<EOF
            ${{ toJSON(env) }}
          EOF)
          JSON_WITHOUT_NEWLINES=$(echo $JSON_WITH_NEWLINES | jq -R -c .)
          echo "EXTRA_VARS=$JSON_WITHOUT_NEWLINES" >> $GITHUB_OUTPUT
        env:
          encrypted_disk_size: ${{ vars.DISK_SPACE }}
          disk_encryption_key: ${{ secrets.ENCRYPTION_KEY }}
          dockerhub_username: ${{ secrets.DOCKER_USERNAME }}
          dockerhub_password: ${{ secrets.DOCKER_TOKEN }}
          mongodb_admin_username: ${{ secrets.MONGODB_ADMIN_USER }}
          mongodb_admin_password: ${{ secrets.MONGODB_ADMIN_PASSWORD }}
          backup_encryption_passphrase: ${{ secrets.BACKUP_ENCRYPTION_PASSPHRASE }}
          elasticsearch_superuser_password: ${{ secrets.ELASTICSEARCH_SUPERUSER_PASSWORD }}
          manager_production_server_ip: ${{ vars.SSH_HOST || secrets.SSH_HOST }}
          ansible_user: ${{ secrets.SSH_USER }}

      - name: Read known hosts
        run: |
          cd ${{ github.event.repository.name }}
          echo "KNOWN_HOSTS<<EOF" >> $GITHUB_ENV
          sed -i -e '$a\' ./infrastructure/known-hosts
          cat ./infrastructure/known-hosts >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Install SSH Key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_KEY }}
          known_hosts: ${{ env.KNOWN_HOSTS }}

      - name: Write backup SSH key to file
        if: needs.check-backup-environment.outputs.backup_env_exists == 'true'
        run: |
          echo "${{ needs.fetch-backup-credentials.outputs.backup-ssh-key }}" | base64 --decode | \
          openssl enc -aes-256-cbc -pbkdf2 -d -salt -k "${{ secrets.GH_ENCRYPTION_PASSWORD }}" -out /tmp/backup_ssh_private_key
          chmod 600 /tmp/backup_ssh_private_key

      - name: Check if backup environment if configured in inventory file
        if: needs.check-backup-environment.outputs.backup_env_exists != 'true'
        run: |
          FILE=./${{ github.event.repository.name }}/infrastructure/server-setup/inventory/${{ github.event.inputs.environment }}.yml
          if grep -q "backups: " "$FILE"; then
            echo "Your inventory contains configuration for either a backup target or backup source."
            echo "If you are upgrading OpenCRVS, please start by running environment creator script for the backup server"
            echo ""
            echo "yarn environment:init --environment=backup"
            echo ""
            echo "And after that, run this provisioning pipeline again but first to your backup server"
            echo "After that you can proceed with (re)provisioning your staging and production servers."
            exit 1
          fi
      - name: Setup tmate session
        if: ${{ github.event.inputs.debug == 'true' }}
        uses: mxschmitt/action-tmate@v3
        env:
          encrypted_disk_size: ${{ vars.DISK_SPACE }}
          disk_encryption_key: ${{ secrets.ENCRYPTION_KEY }}
          dockerhub_username: ${{ secrets.DOCKER_USERNAME }}
          dockerhub_password: ${{ secrets.DOCKER_TOKEN }}
          mongodb_admin_username: ${{ secrets.MONGODB_ADMIN_USER }}
          mongodb_admin_password: ${{ secrets.MONGODB_ADMIN_PASSWORD }}
          backup_encryption_passphrase: ${{ secrets.BACKUP_ENCRYPTION_PASSPHRASE }}
          elasticsearch_superuser_password: ${{ secrets.ELASTICSEARCH_SUPERUSER_PASSWORD }}
          manager_production_server_ip: ${{ vars.SSH_HOST || secrets.SSH_HOST }}
          ansible_user: ${{ secrets.SSH_USER }}

      - name: Run playbook
        uses: dawidd6/action-ansible-playbook@v2.8.0
        env:
          ANSIBLE_PERSISTENT_COMMAND_TIMEOUT: 10
          ANSIBLE_SSH_TIMEOUT: 10
          ANSIBLE_SSH_RETRIES: 5
        with:
          playbook: playbook.yml
          directory: ${{ github.event.repository.name }}/infrastructure/server-setup
          options: |
            --verbose
            --inventory inventory/${{ github.event.inputs.environment }}.yml
            ${{ inputs.tag != 'all' && format('--tags={0}', inputs.tag) || ''}}
            --extra-vars ""${{ steps.ansible-variables.outputs.EXTRA_VARS }}""
